#!/bin/bash
# SGE Parameters
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
# set -uo pipefail
IFS=$'\n\t'
shopt -s nullglob

# Index the data generated by processLIDC

# Some variables
if [ `uname` = 'Linux' ]; then

    # Linux paths
    export JAVA_HOME=/software/jvm/jdk1.8.0_20
    export PATH=$PATH:$JAVA_HOME/bin:/software/bin:/software/python
    export LD_LIBRARY_PATH=/software/lib
    export JAVA_OPTS="-Xmx2g"
    # Python Virtual env
    source /software/lidc-venv/bin/activate

    # Get the XML file to run
    XMLORIG=/software/$(sed "${JOBID}q;d" /software/lidc.txt)
    algorithm_dir=/software/algorithms
else
    # Mac path
    PATH=`pwd`/build/install/LIDCTooling/bin:$PATH
    PATH=`pwd`/../ChestImagingPlatform/build/CIP-build/bin/:`pwd`/python/:${PATH}
    XMLORIG=ClusterSoftware/tcia-lidc-xml/157/158.xml
fi

# in 'main' we can reference functions later in the script
main() {
    # Database name
    DB=${1:-lidc.db}
    DB=$(fullPath $DB)
    
    createDB
    wd=$(pwd)
    # Index the reads
    for dir in segmented/*; do
        cd $wd
        indexRead $dir
        cd $wd
        indexFeatures $dir
        cd $wd
        indexMeasures $dir
        cd $wd
        captureErrors $dir
    done
    
}


function indexMeasures {
    dir=$1
    cd $dir
    # Process all the measures
    printf "Measures"
    for fid in *_measures.json; do
        printf "."
        uid=$(jq -r '"\(.algorithm)-\(.nodule_uid)"' $fid)
        getValues $fid . $uid measures
        getValues $fid .measures $uid measures
        sqlite3 $DB <<EOF
update measures set path = '$dir' where uid = '$uid';
EOF
    done
    printf "\n"
}

function indexRead {
    dir=$1
    cd $dir
    getValues reads.json . $(jq -r .uid reads.json) series

    for read_id in $(jq -r ".reads[].id" reads.json); do
        read_uid=$(jq -r ".reads[] | select(.id == $read_id) | .uid" reads.json)
        echo Read: $read_id uid $read_uid
        getValues reads.json ".reads[] | select(.id == $read_id)" $read_uid reads
        printf "Nodules"
        for nodule_id in $(jq -r ".reads[] | select(.uid == \"$read_uid\") | .nodules[].id" reads.json); do
            # printf "%s\n" "Processing Nodule: $nodule_uid"
            printf "."
            jq ".reads[].nodules[] | select ( .id == \"$nodule_id\" )" reads.json > nodule.json
            nodule_uid=$(jq -r .uid nodule.json)
            getValues nodule.json . $nodule_uid nodules
            getValues nodule.json .characteristics $nodule_uid nodules
            sqlite3 $DB <<EOF
 update nodules set read_uid = '$read_uid' where uid = '$nodule_uid';
EOF
            #         nodule_uid=$(echo $nodule | jq -r ".uid")
        done
        printf "\n"
    done

    
    #     read=$(jq ".reads[] | select(.id == $read_id)" reads.json)
    #     read_uid=$(echo $read | jq -r ".uid")
    #     for nodule_id in $(echo $read | jq -r ".nodules[].id"); do
    #         nodule=$(echo $read | jq ".nodules[] | select ( .id == \"$nodule_id\" )")
    #         nodule_uid=$(echo $nodule | jq -r ".uid")
    #         normalized_nodule_id=$(echo $nodule | jq -r ".normalized_nodule_id")
    
}

function indexFeatures {
    dir=$1
    cd $dir
    printf "Features"
    for fid in *_features.json; do
        printf "."
        uid=$(jq -r '"\(.algorithm)-\(.nodule_uid)"' $fid)
        getValues $fid . $uid features
        getValues $fid ".first_order, .glcm, .glszm, .rlgl, .shape" $uid features
        # for t in first_order glcm glszm rlgl shape; do
        #     getValues $fid .${t} $uid features
        # done
    done
    printf "\n"
}


function captureErrors {
    dir=$1
    cd $dir
    length=$(jq -r '.errors | length' error.json)
    echo Processing $length errors in $dir
    ((length = length - 1))
    # length=$(echo $((length--)))
    for i in `seq 0 $length`; do
        uid=$(uuidgen)
        getValues error.json ".errors[$i]" $uid errors
        p=$(jq -r ".errors[$i].log" error.json)
        sqlite3 $DB <<EOF
update errors set path = '$dir/$p' where uid = '$uid';
EOF
    done
}

function fullPath {
    echo "$(cd "$(dirname "$1")"; pwd)/$(basename "$1")"
}

# Take a json file, JSON path, uid, and table to insert values into
function getValues {
    file=$1
    path=$2
    uid=$3
    table=$4
    # echo $file $path $uid $table
    sqlite3 $DB <<EOF
insert or ignore into $table ( uid ) values ( '$uid' );
EOF
    sql=""
    # Get all the keys, but ignore keys named "uid"
    for key in $(jq -r "$path | keys | .[]" $file); do
        if [[ $tableinfo == *${key}* ]] && [[ $key != "uid" ]]; then
            value=$(jq -r "$path | .[\"$key\"] // \"\" " $file | sed "s/'/''/g")
            sql+="update or ignore $table set $key = '$value' where uid = '$uid'; "
        fi
    done
    echo $sql | sqlite3 $DB
#     <<EOF
#  update or ignore $table set $key = '$value' where uid = '$uid';
# EOF
}

function createDB {
# Create the database
sqlite3 $DB <<EOF
create table if not exists series (
  uid text primary key,
  series_instance_uid text,
  study_instance_uid text,
  patient_name text,
  patient_id text,
  manufacturer text,
  manufacturer_model_name text,
  patient_sex text,
  patient_age text,
  ethnic_group text,
  contrast_bolus_agent text,
  body_part_examined text,
  scan_options text,
  slice_thickness float,
  kvp float,
  data_collection_diameter float,
  software_versions text,
  reconstruction_diameter float,
  gantry_detector_tilt float,
  table_height float,
  rotation_direction text,
  exposure_time float,
  xray_tube_current float,
  exposure float,
  convolution_kernel text,
  patient_position text,
  image_position_patient text,
  image_orientation_patient text,
  filename text );

create table if not exists reads (
  uid text primary key,
  filename text,
  id text
);

create table if not exists nodules (
  uid text primary key,
  read_uid text,
  normalized_nodule_id int,
  id text,
  centroid text,
  centroidLPS text,
  point_count int,
  label_value int,
  subtlety int,
  internalStructure int,
  calcification int,
  sphericity int,
  margin int,
  lobulation int,
  spiculation int,
  texture int,
  malignancy int  
);

create table if not exists measures (
  uid text primary key,
  nodule_uid text,
  read_uid text,
  path text,
  algorithm text,
  command_line text,
  false_negative_error float,
  dice_coefficient float,
  volume_similarity float,
  false_positive_error float,
  mean_overlap float,
  union_overlap float,
  jaccard_coefficient float,
  hausdorff_distance float,
  average_hausdorff_distance float
);

create table if not exists errors (
  uid text primary key,
  path text,
  name text,
  log text,
  text text
);

create table if not exists features (
  uid text primary key,
  nodule_uid text,
  read_uid text,
  algorithm text,
  LoG_sigma_05_Energy real,
  LoG_sigma_05_Entropy real,
  LoG_sigma_05_Kurtosis real,
  LoG_sigma_05_Maximum real,
  LoG_sigma_05_Mean real,
  LoG_sigma_05_MeanDeviation real,
  LoG_sigma_05_Median real,
  LoG_sigma_05_Minimum real,
  LoG_sigma_05_Range real,
  LoG_sigma_05_RootMeanSquared real,
  LoG_sigma_05_Skewness real,
  LoG_sigma_05_StandardDeviation real,
  LoG_sigma_05_TotalEnergy real,
  LoG_sigma_05_Uniformity real,
  LoG_sigma_05_Variance real,
  LoG_sigma_10_Energy real,
  LoG_sigma_10_Entropy real,
  LoG_sigma_10_Kurtosis real,
  LoG_sigma_10_Maximum real,
  LoG_sigma_10_Mean real,
  LoG_sigma_10_MeanDeviation real,
  LoG_sigma_10_Median real,
  LoG_sigma_10_Minimum real,
  LoG_sigma_10_Range real,
  LoG_sigma_10_RootMeanSquared real,
  LoG_sigma_10_Skewness real,
  LoG_sigma_10_StandardDeviation real,
  LoG_sigma_10_TotalEnergy real,
  LoG_sigma_10_Uniformity real,
  LoG_sigma_10_Variance real,
  LoG_sigma_15_Energy real,
  LoG_sigma_15_Entropy real,
  LoG_sigma_15_Kurtosis real,
  LoG_sigma_15_Maximum real,
  LoG_sigma_15_Mean real,
  LoG_sigma_15_MeanDeviation real,
  LoG_sigma_15_Median real,
  LoG_sigma_15_Minimum real,
  LoG_sigma_15_Range real,
  LoG_sigma_15_RootMeanSquared real,
  LoG_sigma_15_Skewness real,
  LoG_sigma_15_StandardDeviation real,
  LoG_sigma_15_TotalEnergy real,
  LoG_sigma_15_Uniformity real,
  LoG_sigma_15_Variance real,
  LoG_sigma_20_Energy real,
  LoG_sigma_20_Entropy real,
  LoG_sigma_20_Kurtosis real,
  LoG_sigma_20_Maximum real,
  LoG_sigma_20_Mean real,
  LoG_sigma_20_MeanDeviation real,
  LoG_sigma_20_Median real,
  LoG_sigma_20_Minimum real,
  LoG_sigma_20_Range real,
  LoG_sigma_20_RootMeanSquared real,
  LoG_sigma_20_Skewness real,
  LoG_sigma_20_StandardDeviation real,
  LoG_sigma_20_TotalEnergy real,
  LoG_sigma_20_Uniformity real,
  LoG_sigma_20_Variance real,
  LoG_sigma_25_Energy real,
  LoG_sigma_25_Entropy real,
  LoG_sigma_25_Kurtosis real,
  LoG_sigma_25_Maximum real,
  LoG_sigma_25_Mean real,
  LoG_sigma_25_MeanDeviation real,
  LoG_sigma_25_Median real,
  LoG_sigma_25_Minimum real,
  LoG_sigma_25_Range real,
  LoG_sigma_25_RootMeanSquared real,
  LoG_sigma_25_Skewness real,
  LoG_sigma_25_StandardDeviation real,
  LoG_sigma_25_TotalEnergy real,
  LoG_sigma_25_Uniformity real,
  LoG_sigma_25_Variance real,
  LoG_sigma_30_Energy real,
  LoG_sigma_30_Entropy real,
  LoG_sigma_30_Kurtosis real,
  LoG_sigma_30_Maximum real,
  LoG_sigma_30_Mean real,
  LoG_sigma_30_MeanDeviation real,
  LoG_sigma_30_Median real,
  LoG_sigma_30_Minimum real,
  LoG_sigma_30_Range real,
  LoG_sigma_30_RootMeanSquared real,
  LoG_sigma_30_Skewness real,
  LoG_sigma_30_StandardDeviation real,
  LoG_sigma_30_TotalEnergy real,
  LoG_sigma_30_Uniformity real,
  LoG_sigma_30_Variance real,
  LoG_sigma_35_Energy real,
  LoG_sigma_35_Entropy real,
  LoG_sigma_35_Kurtosis real,
  LoG_sigma_35_Maximum real,
  LoG_sigma_35_Mean real,
  LoG_sigma_35_MeanDeviation real,
  LoG_sigma_35_Median real,
  LoG_sigma_35_Minimum real,
  LoG_sigma_35_Range real,
  LoG_sigma_35_RootMeanSquared real,
  LoG_sigma_35_Skewness real,
  LoG_sigma_35_StandardDeviation real,
  LoG_sigma_35_TotalEnergy real,
  LoG_sigma_35_Uniformity real,
  LoG_sigma_35_Variance real,
  LoG_sigma_40_Energy real,
  LoG_sigma_40_Entropy real,
  LoG_sigma_40_Kurtosis real,
  LoG_sigma_40_Maximum real,
  LoG_sigma_40_Mean real,
  LoG_sigma_40_MeanDeviation real,
  LoG_sigma_40_Median real,
  LoG_sigma_40_Minimum real,
  LoG_sigma_40_Range real,
  LoG_sigma_40_RootMeanSquared real,
  LoG_sigma_40_Skewness real,
  LoG_sigma_40_StandardDeviation real,
  LoG_sigma_40_TotalEnergy real,
  LoG_sigma_40_Uniformity real,
  LoG_sigma_40_Variance real,
  LoG_sigma_45_Energy real,
  LoG_sigma_45_Entropy real,
  LoG_sigma_45_Kurtosis real,
  LoG_sigma_45_Maximum real,
  LoG_sigma_45_Mean real,
  LoG_sigma_45_MeanDeviation real,
  LoG_sigma_45_Median real,
  LoG_sigma_45_Minimum real,
  LoG_sigma_45_Range real,
  LoG_sigma_45_RootMeanSquared real,
  LoG_sigma_45_Skewness real,
  LoG_sigma_45_StandardDeviation real,
  LoG_sigma_45_TotalEnergy real,
  LoG_sigma_45_Uniformity real,
  LoG_sigma_45_Variance real,
  LoG_sigma_50_Energy real,
  LoG_sigma_50_Entropy real,
  LoG_sigma_50_Kurtosis real,
  LoG_sigma_50_Maximum real,
  LoG_sigma_50_Mean real,
  LoG_sigma_50_MeanDeviation real,
  LoG_sigma_50_Median real,
  LoG_sigma_50_Minimum real,
  LoG_sigma_50_Range real,
  LoG_sigma_50_RootMeanSquared real,
  LoG_sigma_50_Skewness real,
  LoG_sigma_50_StandardDeviation real,
  LoG_sigma_50_TotalEnergy real,
  LoG_sigma_50_Uniformity real,
  LoG_sigma_50_Variance real,
  Mean real,
  Autocorrelation real,
  ClusterProminence real,
  ClusterShade real,
  ClusterTendency real,
  Contrast real,
  Correlation real,
  DifferenceEntropy real,
  Dissimilarity real,
  Energy real,
  Entropy real,
  Homogeneity1 real,
  Homogeneity2 real,
  Idmn real,
  Idn real,
  Imc1 real,
  Imc2 real,
  InverseVariance real,
  MaximumProbability real,
  SumAverage real,
  SumEntropy real,
  SumSquares real,
  SumSquares2 real,
  SumVariance real,
  SumVariance2 real,
  HighIntensityEmphasis real,
  HighIntensityLargeAreaEmphasis real,
  HighIntensitySmallAreaEmphasis real,
  IntensityVariability real,
  LargeAreaEmphasis real,
  LowIntensityEmphasis real,
  LowIntensityLargeAreaEmphasis real,
  LowIntensitySmallAreaEmphasis real,
  SizeZoneVariability real,
  SmallAreaEmphasis real,
  ZonePercentage real,
  GrayLevelNonUniformity real,
  HighGrayLevelRunEmphasis real,
  LongRunEmphasis real,
  LongRunHighGrayLevelEmphasis real,
  LongRunLowGrayLevelEmphasis real,
  LowGrayLevelRunEmphasis real,
  RunLengthNonUniformity real,
  RunPercentage real,
  ShortRunEmphasis real,
  ShortRunHighGrayLevelEmphasis real,
  ShortRunLowGrayLevelEmphasis real,
  Compactness1 real,
  Compactness2 real,
  Maximum3DDiameter real,
  SphericalDisproportion real,
  Sphericity real,
  SurfaceArea real,
  SurfaceVolumeRatio real,
  Volume real
  );

EOF
tableinfo=" "
for table in measures nodules reads series errors features; do
    tableinfo+=$(sqlite3 -separator : $DB "pragma table_info($table)" | tail -n +1 | awk -F':' '{print " ", $2}'  )
done
# Remove uid, including at the beginning of the string
tableinfo=$(echo $tableinfo | sed 's/[[:space:]]uid//g' | sed 's/^uid//g')
sqlite3 $DB "delete from errors;"
}

main "$@"
